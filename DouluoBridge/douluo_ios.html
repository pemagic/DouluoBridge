<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ÊñóÁΩóÂ§ßÊ°•ÔºöÂÉèÁ¥†ÂâëÂΩ±</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            width: 100vw;
            height: 100vh;
        }

        #canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            transform-origin: 0 0;
            position: absolute;
            top: 0;
            left: 0;
        }

        .crt::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            z-index: 100;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        .font-game {
            font-weight: 900;
        }

        .glowing-text {
            text-shadow: 0 0 15px rgba(220, 38, 38, 0.9);
        }

        #ui-layer {
            pointer-events: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-btn {
            pointer-events: auto;
        }

        /* Main Menu Styles */
        #main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #main-menu .version-tag {
            margin-bottom: 8px;
            padding: 4px 16px;
            background: #b91c1c;
            color: white;
            font-weight: bold;
            font-size: 11px;
            letter-spacing: 3px;
            text-transform: uppercase;
            box-shadow: 0 0 15px rgba(185, 28, 28, 0.5);
        }

        #main-menu h1 {
            font-size: 72px;
            font-weight: 900;
            color: white;
            margin-bottom: 24px;
        }

        #main-menu .subtitle {
            font-size: 16px;
            color: #ef4444;
            font-family: monospace;
            letter-spacing: 6px;
            text-transform: uppercase;
            margin-bottom: 24px;
        }

        #main-menu .start-btn {
            padding: 16px 48px;
            background: transparent;
            border: 3px solid white;
            color: white;
            font-weight: 900;
            font-size: 28px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        #main-menu .start-btn:active {
            border-color: #dc2626;
            background: rgba(185, 28, 28, 0.5);
        }

        /* HUD Styles */
        #hud {
            display: none;
            position: absolute;
            top: 20px;
            left: 20px;
            flex-direction: column;
            align-items: flex-start;
        }

        #hud.visible {
            display: flex;
        }

        .hp-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .hp-bar-bg {
            width: 160px;
            height: 10px;
            background: #111;
            border: 1.5px solid #7f1d1d;
        }

        #hp-bar {
            height: 100%;
            background: #dc2626;
            width: 100%;
            box-shadow: 0 0 10px #dc2626;
        }

        .ult-bar-bg {
            width: 120px;
            height: 6px;
            background: #111;
            border: 1px solid #713f12;
            margin-top: 4px;
        }

        #ult-bar {
            height: 100%;
            background: #eab308;
            width: 0;
        }

        #weapon-rank-display {
            font-weight: 900;
            font-size: 14px;
            color: white;
            font-style: italic;
        }

        #kill-counter {
            color: rgba(255, 255, 255, 0.7);
            font-weight: 900;
            font-size: 18px;
            margin-top: 6px;
        }

        #combo-container {
            opacity: 0;
            transition: opacity 0.3s;
        }

        #combo-counter {
            color: #dc2626;
            font-weight: 900;
            font-size: 32px;
            font-style: italic;
        }

        /* Game Over Styles */
        #game-over {
            display: none;
            flex-direction: column;
            align-items: center;
        }

        #game-over.visible {
            display: flex;
        }

        #game-over h1 {
            font-size: 56px;
            font-weight: 900;
            color: #dc2626;
            margin-bottom: 16px;
        }

        #final-stats {
            color: white;
            font-weight: 900;
            font-size: 16px;
            margin-bottom: 16px;
        }

        #game-over .restart-btn {
            padding: 12px 36px;
            border: 2px solid #dc2626;
            color: #ef4444;
            font-weight: 900;
            font-size: 20px;
            background: transparent;
            cursor: pointer;
        }

        #game-over .restart-btn:active {
            background: #dc2626;
            color: white;
        }

        .hidden {
            display: none !important;
        }

        .ultimate-ready {
            animation: pulse-gold 1s infinite;
        }

        @keyframes pulse-gold {
            0% {
                box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(250, 204, 21, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(250, 204, 21, 0);
            }
        }

        /* Pause/Home buttons */
        .hud-top-right {
            position: fixed;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 10px;
            z-index: 200;
        }

        .hud-btn {
            pointer-events: auto;
            width: 40px;
            height: 40px;
            border-radius: 10px;
            border: 2px solid rgba(80, 70, 55, 0.6);
            background: rgba(40, 35, 28, 0.5);
            color: #c0b090;
            font-size: 18px;
            font-weight: 900;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .hud-btn:active {
            background: rgba(80, 70, 55, 0.7);
        }

        /* Level banner */
        #level-banner {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 300;
            background: rgba(0, 0, 0, 0.7);
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        #level-banner.visible {
            display: flex;
        }

        #level-banner h2 {
            color: #c0b090;
            font-size: 48px;
            font-weight: 900;
            text-shadow: 0 0 20px rgba(200, 180, 140, 0.5);
        }

        #level-banner p {
            color: #a09080;
            font-size: 20px;
            margin-top: 10px;
        }

        /* Pause overlay */
        #pause-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 280;
            background: rgba(0, 0, 0, 0.6);
            align-items: center;
            justify-content: center;
        }

        #pause-overlay.visible {
            display: flex;
        }

        #pause-overlay h2 {
            color: #c0b090;
            font-size: 56px;
            font-weight: 900;
        }

        #level-display {
            color: #c0b090;
            font-size: 14px;
            font-weight: 900;
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
        }
    </style>
</head>

<body class="crt" style="background: #000;">
    <div id="ui-layer">
        <!-- Main Menu -->
        <div id="main-menu">
            <div class="version-tag">PIXEL WUXIA v7.1</div>
            <h1 class="font-game glowing-text">ÊñóÁΩóÂ§ßÊ°•</h1>
            <p class="subtitle">‰∏áÂâëÂΩíÂÆó | Ten Thousand Swords</p>
            <button onclick="startGame()" class="menu-btn start-btn font-game">
                ÊùÄÂá∫Ë°ÄË∑Ø
            </button>
        </div>

        <!-- HUD -->
        <div id="hud">
            <div class="hp-container">
                <div class="hp-bar-bg">
                    <div id="hp-bar"></div>
                </div>
                <div id="weapon-rank-display" class="font-game">Â¢ÉÁïåÔºöÂàùÂÖ•Ê±üÊπñ [Lv.1]</div>
            </div>
            <div class="ult-bar-bg">
                <div id="ult-bar"></div>
            </div>
            <div id="kill-counter" class="font-game">Êñ©Êïå: 0</div>
            <div id="combo-container">
                <div id="combo-counter" class="font-game">10 COMBO</div>
            </div>
            <div id="level-display" class="font-game">Á¨¨‰∏ÄÂÖ≥</div>
            <div class="hud-top-right">
                <button class="hud-btn" id="btn-pause" onclick="togglePause()">‚è∏</button>
                <button class="hud-btn" id="btn-home" onclick="returnHome()">üè†</button>
            </div>
        </div>

        <!-- Pause Overlay -->
        <div id="pause-overlay">
            <h2 class="font-game">ÊöÇ ÂÅú</h2>
        </div>

        <!-- Level Banner -->
        <div id="level-banner">
            <h2 id="level-title" class="font-game"></h2>
            <p id="level-subtitle" class="font-game"></p>
        </div>

        <!-- Game Over -->
        <div id="game-over">
            <h1 class="font-game">Ê∞îÂ∞Ω‰∫∫‰∫°</h1>
            <div id="final-stats" class="font-game"></div>
            <button onclick="location.reload()" class="menu-btn restart-btn font-game">ËΩ¨‰∏ñÂÜçÊù•</button>
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        // iOS key bridge - called from native Swift code
        window.iosSetKey = function (code, pressed) {
            if (pressed) {
                keys[code] = true;
                // Handle one-shot actions
                if (!gameRunning) return;
                if ((code === 'Space') && player.jumpCount < 2) {
                    player.vy = JUMP_FORCE; player.jumpCount++; playTone(400, 'sine', 0.1, 0.1);
                }
                if ((code === 'ShiftLeft') && player.dashCooldown <= 0) {
                    player.dashActive = 15; player.dashCooldown = 180;
                    playTone(200, 'sawtooth', 0.3, 0.15);
                    haptic('heavy');
                    const dashStartX = player.x;
                    const dashEndX = player.x + player.facing * DASH_FORCE * 15;
                    const dashMinX = Math.min(dashStartX, dashEndX) - 40;
                    const dashMaxX = Math.max(dashStartX, dashEndX) + 40;
                    for (let ei = enemies.length - 1; ei >= 0; ei--) {
                        const e = enemies[ei];
                        if (e.x + e.w > dashMinX && e.x < dashMaxX && Math.abs(e.y - player.y) < 120) {
                            createParticles(e.x + e.w / 2, e.y + e.h / 2, '#ff4444', 20, 2, 2);
                            enemies.splice(ei, 1);
                            kills++; combo++; comboTimer = 150;
                            player.energy = Math.min(100, player.energy + 4);
                            spawnDrop(e.x + e.w / 2, e.y + e.h / 2);
                        }
                    }
                    haptic('heavy');
                }
                if (code === 'KeyL' && player.energy >= 100) {
                    player.energy = 0; player.ultActive = 240; player.iframe = 240;
                    playTone(100, 'sawtooth', 1.0, 0.5);
                    createParticles(player.x, player.y, '#fff', 50, 3);
                    haptic('heavy');
                }
                // Manual attack (KeyJ)
                if (code === 'KeyJ') {
                    playerShoot();
                }
                // Skill activations
                activateSkill(code);
            } else {
                keys[code] = false;
            }
        };

        // === Skill activation ===
        function activateSkill(code) {
            for (const [id, def] of Object.entries(SKILL_DEFS)) {
                if (code !== def.key) continue;
                const sk = playerSkills[id];
                if (sk.level <= 0 || sk.cooldown > 0) return;
                const lvl = sk.level;
                const px = player.x + player.w / 2;
                const py = player.y + player.h / 2;

                if (id === 'fire') {
                    // Fire Palm: forward fire wave
                    const dmg = def.baseDmg + lvl * 15;
                    const count = 1 + Math.floor(lvl / 3);
                    for (let i = 0; i < count; i++) {
                        projectiles.push({ x: px, y: py + (i - count / 2) * 12, vx: player.facing * (35 + lvl * 2), vy: (i - count / 2) * 2, owner: 'player', color: def.color, life: 40 + lvl * 3, dmg, size: 14 + lvl });
                    }
                    createParticles(px, py, def.color, 10 + lvl, 2);
                    sk.cooldown = Math.max(40, def.baseCd - lvl * 8);
                } else if (id === 'whirlwind') {
                    // Whirlwind: AoE spin attack
                    const dmg = def.baseDmg + lvl * 12;
                    const radius = 100 + lvl * 15;
                    const count = 4 + Math.floor(lvl / 2);
                    for (let i = 0; i < count; i++) {
                        const a = (i / count) * Math.PI * 2;
                        projectiles.push({ x: px, y: py, vx: Math.cos(a) * 20, vy: Math.sin(a) * 20, owner: 'player', color: def.color, life: 25 + lvl * 2, dmg, size: 12 + lvl });
                    }
                    createParticles(px, py, def.color, 15, 2.5);
                    sk.cooldown = Math.max(50, def.baseCd - lvl * 10);
                } else if (id === 'shield') {
                    // Iron Shirt: temporary damage reduction
                    sk.active = def.baseDur + lvl * 20;
                    createParticles(px, py, def.color, 20, 1.5);
                    sk.cooldown = Math.max(100, def.baseCd - lvl * 15);
                } else if (id === 'lightning') {
                    // Lightning: random bolts on nearby enemies
                    const dmg = def.baseDmg + lvl * 20;
                    const bolts = 1 + Math.floor(lvl / 2);
                    let targets = enemies.filter(e => isOnScreen(e)).slice(0, bolts);
                    targets.forEach(e => {
                        e.hp -= dmg;
                        e.damageFlash = 10;
                        createParticles(e.x + e.w / 2, e.y + e.h / 2, def.color, 12, 2);
                    });
                    if (targets.length > 0) haptic('medium');
                    sk.cooldown = Math.max(60, def.baseCd - lvl * 12);
                } else if (id === 'ghost') {
                    // Ghost Claw: homing projectile
                    const dmg = def.baseDmg + lvl * 18;
                    const count = 1 + Math.floor(lvl / 4);
                    for (let i = 0; i < count; i++) {
                        projectiles.push({ x: px, y: py - i * 20, vx: player.facing * 15, vy: -5 + i * 3, owner: 'player', color: def.color, life: 80 + lvl * 5, dmg, size: 14, homing: true });
                    }
                    createParticles(px, py, def.color, 8, 2);
                    sk.cooldown = Math.max(60, def.baseCd - lvl * 12);
                }

                playTone(300 + lvl * 50, 'sawtooth', 0.15, 0.2);
                haptic('medium');
                return;
            }
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const ui = {
            menu: document.getElementById('main-menu'),
            over: document.getElementById('game-over'),
            hud: document.getElementById('hud'),
            hp: document.getElementById('hp-bar'),
            ult: document.getElementById('ult-bar'),
            kills: document.getElementById('kill-counter'),
            combo: document.getElementById('combo-counter'),
            comboContainer: document.getElementById('combo-container'),
            rank: document.getElementById('weapon-rank-display'),
            stats: document.getElementById('final-stats')
        };

        // Fixed game resolution for zoomed-out view showing more content
        const GAME_WIDTH = 1600;
        const GAME_HEIGHT = 900;
        let canvasScale = 1;

        const GRAVITY = 1.3;
        const PLAYER_SPEED = 14;
        const JUMP_FORCE = -25;
        const DASH_FORCE = 52;
        const NEON_COLORS = ['#ff00ff', '#00ffff', '#ffff00', '#00ff00', '#ff0000', '#ff8800', '#00ff88', '#8800ff', '#ffffff'];

        let gameRunning = false;
        let gamePaused = false;
        let gameLoopRunning = false;
        let kills = 0;
        let combo = 0;
        let comboTimer = 0;
        let gameTime = 0;
        let hitstop = 0;
        let camX = 0, camY = 0;
        let spawnCooldown = 0;

        // === 10-Level System ===
        let currentLevel = 1;
        let levelKills = 0; // kills this level
        let bossActive = false;
        let bossSpawned = false;
        const LEVELS = [
            { name: 'Á¨¨‰∏ÄÂÖ≥¬∑ÂàùÂÖ•Ê±üÊπñ', killTarget: 15, weaponCap: 2, enemyTier: 1, enemies: ['scout'], bossHp: 600, bossSpeed: 1.0, bossType: 'bandit_chief' },
            { name: 'Á¨¨‰∫åÂÖ≥¬∑Â¥≠Èú≤ÈîãËäí', killTarget: 20, weaponCap: 3, enemyTier: 1, enemies: ['scout', 'chaser'], bossHp: 900, bossSpeed: 1.1, bossType: 'wolf_king' },
            { name: 'Á¨¨‰∏âÂÖ≥¬∑Êã≥ËÑöÁõ∏Âä†', killTarget: 25, weaponCap: 4, enemyTier: 1, enemies: ['scout', 'chaser', 'martial'], bossHp: 1200, bossSpeed: 1.2, bossType: 'iron_fist' },
            { name: 'Á¨¨ÂõõÂÖ≥¬∑ÈìÅÁî≤ËøûÂüé', killTarget: 30, weaponCap: 5, enemyTier: 2, enemies: ['scout', 'chaser', 'martial', 'heavy'], bossHp: 1600, bossSpeed: 1.3, bossType: 'shield_general' },
            { name: 'Á¨¨‰∫îÂÖ≥¬∑ÁôæÊ≠•Á©øÊù®', killTarget: 35, weaponCap: 6, enemyTier: 2, enemies: ['scout', 'chaser', 'martial', 'heavy', 'sniper'], bossHp: 2000, bossSpeed: 1.4, bossType: 'phantom_archer' },
            { name: 'Á¨¨ÂÖ≠ÂÖ≥¬∑ÂàÄÂÖâÂâëÂΩ±', killTarget: 40, weaponCap: 7, enemyTier: 2, enemies: ['chaser', 'martial', 'heavy', 'sniper'], bossHp: 2500, bossSpeed: 1.5, bossType: 'twin_blade' },
            { name: 'Á¨¨‰∏ÉÂÖ≥¬∑Èæô‰∫âËôéÊñó', killTarget: 45, weaponCap: 8, enemyTier: 3, enemies: ['martial', 'heavy', 'sniper', 'chaser'], bossHp: 3200, bossSpeed: 1.7, bossType: 'thunder_monk' },
            { name: 'Á¨¨ÂÖ´ÂÖ≥¬∑‰∏áÂ§´Ëé´Êïå', killTarget: 50, weaponCap: 9, enemyTier: 3, enemies: ['martial', 'heavy', 'sniper'], bossHp: 4000, bossSpeed: 1.9, bossType: 'blood_demon' },
            { name: 'Á¨¨‰πùÂÖ≥¬∑Â§©‰∏ãÊó†Âèå', killTarget: 55, weaponCap: 9, enemyTier: 3, enemies: ['martial', 'heavy', 'sniper'], bossHp: 5000, bossSpeed: 2.1, bossType: 'shadow_lord' },
            { name: 'Á¨¨ÂçÅÂÖ≥¬∑ÂâëÁ•ûÂΩí‰Ωç', killTarget: 60, weaponCap: 10, enemyTier: 3, enemies: ['martial', 'heavy', 'sniper'], bossHp: 7000, bossSpeed: 2.5, bossType: 'sword_saint' },
        ];

        const keys = {};
        const player = {
            x: 400, y: 300, vx: 0, vy: 0, w: 40, h: 64, hp: 100, energy: 0,
            weaponLevel: 1, facing: 1, grounded: false, jumpCount: 0,
            dashCooldown: 0, dashActive: 0, shootTimer: 0, iframe: 0,
            animTime: 0, ultActive: 0
        };

        // === 5-Skill System (10 levels each) ===
        const SKILL_DEFS = {
            fire: { name: 'ÁÅ´ÁÑ∞Êéå', emoji: 'üî•', color: '#ff4400', key: 'KeyQ', baseCd: 120, baseDmg: 40 },
            whirlwind: { name: 'ÊóãÈ£éËÖø', emoji: 'üåÄ', color: '#00ccff', key: 'KeyE', baseCd: 150, baseDmg: 30 },
            shield: { name: 'ÈìÅÂ∏ÉË°´', emoji: 'üõ°', color: '#ffcc00', key: 'KeyR', baseCd: 300, baseDur: 60 },
            lightning: { name: 'Èõ∑ÂáªÊúØ', emoji: '‚ö°', color: '#aa66ff', key: 'KeyT', baseCd: 180, baseDmg: 60 },
            ghost: { name: 'ÂπΩÂÜ•Áà™', emoji: 'üíÄ', color: '#33ff88', key: 'KeyY', baseCd: 200, baseDmg: 50 },
        };
        const playerSkills = {
            fire: { level: 0, cooldown: 0 },
            whirlwind: { level: 0, cooldown: 0 },
            shield: { level: 0, cooldown: 0, active: 0 },
            lightning: { level: 0, cooldown: 0 },
            ghost: { level: 0, cooldown: 0 },
        };

        const enemies = [];
        const projectiles = [];
        const particles = [];
        const platforms = [];
        const trails = [];
        const drops = [];

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(f, t, d, v) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            try {
                const o = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                o.type = t; o.frequency.setValueAtTime(f, audioCtx.currentTime);
                g.gain.setValueAtTime(v, audioCtx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d);
                o.connect(g); g.connect(audioCtx.destination);
                o.start(); o.stop(audioCtx.currentTime + d);
            } catch (e) { }
        }

        // iOS Haptic feedback bridge
        function haptic(type) {
            try {
                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.haptic) {
                    window.webkit.messageHandlers.haptic.postMessage(type || 'light');
                }
            } catch (e) { }
        }

        // === Chinese Classical BGM System ===
        // Melodies inspired by traditional Chinese pieces (Ê≤ßÊµ∑‰∏ÄÂ£∞Á¨ë, È´òÂ±±ÊµÅÊ∞¥, etc.)
        const BGM = {
            playing: false,
            nextNoteTime: 0,
            droneOsc: null,
            droneGain: null,
            // G pentatonic: G A B D E (most natural Chinese music key)
            scale: [
                98.0, 110.0, 123.5, 146.8, 164.8,   // G2 A2 B2 D3 E3
                196.0, 220.0, 246.9, 293.7, 329.6,   // G3 A3 B3 D4 E4
                392.0, 440.0, 493.9, 587.3, 659.3,   // G4 A4 B4 D5 E5
                784.0, 880.0, 987.8                    // G5 A5 B5
            ],
            // Classic Chinese melody patterns (indices into scale)
            melodies: [
                // Ê≤ßÊµ∑‰∏ÄÂ£∞Á¨ë (Laughing across the Sea) - bold wuxia feel
                [14, 12, 10, 9, 10, 12, 14, 12, 10, 9, 7, 5, 7, 9, 10, 9],
                // È´òÂ±±ÊµÅÊ∞¥ (High Mountains, Flowing Water) - flowing cascade
                [10, 12, 14, 12, 10, 9, 7, 5, 7, 9, 10, 12, 10, 9, 7, 9],
                // Á¨ëÂÇ≤Ê±üÊπñ (Swordsman) - heroic ascending
                [5, 7, 9, 10, 12, 10, 9, 7, 9, 10, 12, 14, 12, 10, 9, 7],
                // Ê¢ÖËä±‰∏âÂºÑ (Plum Blossom) - delicate, ornamental
                [14, 14, 12, 14, 12, 10, 9, 10, 12, 10, 9, 7, 9, 7, 5, 7],
                // Êò•Ê±üËä±ÊúàÂ§ú (Spring River Moonlit Night) - serene, lyrical
                [5, 5, 7, 9, 10, 10, 9, 7, 5, 7, 9, 10, 12, 12, 10, 9],
                // Ê∏îËàüÂî±Êôö (Evening Song of Fisherman) - peaceful closing
                [12, 10, 9, 7, 5, 7, 9, 10, 9, 7, 5, 4, 5, 7, 9, 7],
                // ÂçÅÈù¢Âüã‰ºè (Ambush from All Sides) - intense, combat
                [7, 9, 10, 12, 14, 12, 10, 12, 14, 15, 14, 12, 10, 9, 10, 12],
                // ‰∫åÊ≥âÊò†Êúà (Moon Reflected in Pool) - melancholic beauty
                [9, 10, 12, 10, 9, 7, 5, 7, 9, 10, 9, 7, 5, 4, 5, 7],
            ],
            // Rhythm patterns: 1=quarter, 0.5=eighth, 1.5=dotted quarter, 2=half
            rhythms: [
                [0.5, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 1],
                [0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 0.5, 1, 1, 1.5],
                [1, 0.5, 0.5, 1, 0.5, 0.5, 1, 1, 0.5, 0.5, 0.5, 0.5, 1, 1, 0.5, 1.5],
            ],
            currentMelody: 0,
            melodyPos: 0,
            phraseRest: 0,
            currentRhythm: 0,

            start() {
                if (this.playing) return;
                this.playing = true;
                // Deep bass drone on G2
                this.droneGain = audioCtx.createGain();
                this.droneGain.gain.value = 0.02;
                this.droneGain.connect(audioCtx.destination);
                this.droneOsc = audioCtx.createOscillator();
                this.droneOsc.type = 'sine';
                this.droneOsc.frequency.value = 49.0; // G1 - deep warm bass
                this.droneOsc.connect(this.droneGain);
                this.droneOsc.start();
                // Gentle pulsing on the drone
                const lfo = audioCtx.createOscillator();
                const lfoGain = audioCtx.createGain();
                lfo.frequency.value = 0.15;
                lfoGain.gain.value = 0.008;
                lfo.connect(lfoGain);
                lfoGain.connect(this.droneGain.gain);
                lfo.start();
                this.nextNoteTime = audioCtx.currentTime + 0.8;
                this.scheduleNotes();
            },

            stop() {
                this.playing = false;
                if (this.droneOsc) { try { this.droneOsc.stop(); } catch (e) { } }
                this.droneOsc = null;
            },

            // Guzheng/guqin pluck with natural overtones
            pluckNote(freq, time, duration, volume) {
                const osc = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const osc3 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                // Fundamental
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(freq, time);
                // 2nd harmonic (octave) - quieter
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(freq * 2, time);
                // Gentle vibrato after initial attack (guzheng ÊèâÂº¶)
                osc3.type = 'sine';
                osc3.frequency.value = 5.5;
                const vibGain = audioCtx.createGain();
                vibGain.gain.setValueAtTime(0, time);
                vibGain.gain.linearRampToValueAtTime(freq * 0.006, time + 0.15);
                osc3.connect(vibGain);
                vibGain.connect(osc.frequency);

                // Natural pluck envelope
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(volume, time + 0.005);
                gain.gain.setValueAtTime(volume * 0.85, time + 0.04);
                gain.gain.exponentialRampToValueAtTime(volume * 0.3, time + duration * 0.4);
                gain.gain.exponentialRampToValueAtTime(0.001, time + duration);

                // Warm silk string timbre
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2500, time);
                filter.frequency.exponentialRampToValueAtTime(350, time + duration);
                filter.Q.value = 0.8;

                const harmGain = audioCtx.createGain();
                harmGain.gain.value = 0.3;

                osc.connect(filter);
                osc2.connect(harmGain);
                harmGain.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start(time); osc.stop(time + duration);
                osc2.start(time); osc2.stop(time + duration);
                osc3.start(time); osc3.stop(time + duration);
            },

            scheduleNotes() {
                if (!this.playing) return;
                const now = audioCtx.currentTime;
                while (this.nextNoteTime < now + 0.6) {
                    if (this.phraseRest > 0) {
                        this.nextNoteTime += 0.2;
                        this.phraseRest--;
                        continue;
                    }
                    const melody = this.melodies[this.currentMelody];
                    const rhythm = this.rhythms[this.currentRhythm];
                    const noteIdx = melody[this.melodyPos];
                    const freq = this.scale[noteIdx];
                    const beatDur = rhythm[this.melodyPos % rhythm.length];
                    const noteDur = beatDur * 0.8 + 0.2;
                    const vol = 0.04 + Math.random() * 0.015;
                    this.pluckNote(freq, this.nextNoteTime, noteDur, vol);
                    // Harmony on strong beats
                    if (this.melodyPos % 4 === 0 && noteIdx >= 2) {
                        this.pluckNote(this.scale[noteIdx - 2], this.nextNoteTime + 0.015, noteDur * 0.6, vol * 0.25);
                    }
                    // Octave bass on first beat of phrase
                    if (this.melodyPos === 0 && noteIdx >= 5) {
                        this.pluckNote(this.scale[noteIdx - 5], this.nextNoteTime, noteDur * 1.2, vol * 0.35);
                    }
                    this.melodyPos++;
                    if (this.melodyPos >= melody.length) {
                        this.melodyPos = 0;
                        this.phraseRest = 6; // Breath between phrases
                        this.currentMelody = (this.currentMelody + 1) % this.melodies.length;
                        this.currentRhythm = Math.floor(Math.random() * this.rhythms.length);
                    }
                    // Tempo ~80 BPM with natural rubato
                    this.nextNoteTime += beatDur * 0.38 + Math.random() * 0.04;
                }
                setTimeout(() => this.scheduleNotes(), 180);
            }
        };

        function initPlatforms() {
            platforms.length = 0;
            const groundColors = ['#c8b99a', '#b8a88a', '#d4c4a8', '#bfae94'];
            const floatColors = ['#a09080', '#90806a', '#c0b090'];
            for (let i = 0; i < 500; i++) {
                // Ground platforms - ink wash stone style
                platforms.push({ x: i * 600, y: 700 + Math.random() * 100, w: 650, h: 600, color: groundColors[i % groundColors.length], isGround: true });
                // Mid-level platforms
                if (Math.random() > 0.35) platforms.push({ x: i * 600 + 150, y: 450 - Math.random() * 250, w: 280, h: 22, color: floatColors[Math.floor(Math.random() * floatColors.length)], isGround: false });
                // Floating sky platforms - for more vertical gameplay
                if (Math.random() > 0.5) platforms.push({ x: i * 600 + Math.random() * 400, y: 200 - Math.random() * 180, w: 180 + Math.random() * 120, h: 18, color: floatColors[Math.floor(Math.random() * floatColors.length)], isGround: false });
                if (Math.random() > 0.7) platforms.push({ x: i * 600 + Math.random() * 300, y: 50 - Math.random() * 100, w: 140 + Math.random() * 80, h: 15, color: '#b0a090', isGround: false });
            }
        }

        function createParticles(x, y, color, count, speedScale = 1, sizeScale = 1) {
            // Performance: cap particle count and reduce when many enemies dying
            const maxCount = Math.min(count, particles.length > 300 ? Math.ceil(count * 0.4) : count);
            for (let i = 0; i < maxCount; i++) {
                if (particles.length > 350) particles.shift();
                particles.push({
                    x, y, vx: (Math.random() - 0.5) * 25 * speedScale, vy: (Math.random() - 0.5) * 25 * speedScale,
                    size: (2 + Math.random() * 4) * sizeScale, life: 1, decay: 0.03 + Math.random() * 0.03, color
                });
            }
        }

        // Tier colors: tier1=green tones, tier2=blue tones, tier3=red/purple tones
        const TIER_COLORS = {
            1: ['#66aa44', '#88cc66', '#44aa66', '#55bb55', '#77cc44'],
            2: ['#4488cc', '#5599dd', '#3377bb', '#6699cc', '#4477aa'],
            3: ['#cc4444', '#aa33aa', '#dd5555', '#bb2266', '#cc3388']
        };

        function spawnEnemy(isBoss = false) {
            const side = Math.random() > 0.5 ? 1 : -1;
            const x = player.x + side * (900 + Math.random() * 400);
            const lvl = LEVELS[currentLevel - 1];
            const pool = lvl.enemies;
            const type = isBoss ? 'boss' : pool[Math.floor(Math.random() * pool.length)];
            const lvlBonus = (currentLevel - 1) * 0.12;
            const BULLET_COLORS = ['#ff4466', '#44aaff', '#ffcc00', '#66ff88', '#ff66ff', '#ff8844', '#44ffdd', '#aa66ff'];
            const tierColors = TIER_COLORS[lvl.enemyTier];

            const BOSS_COLORS = {
                bandit_chief: '#cc8833', wolf_king: '#888888', iron_fist: '#ff8800',
                shield_general: '#4488cc', phantom_archer: '#33cc99', twin_blade: '#cc44cc',
                thunder_monk: '#ffcc00', blood_demon: '#cc0000', shadow_lord: '#6633cc', sword_saint: '#ffffff'
            };

            const e = {
                x, y: -200, vx: 0, vy: 0,
                w: isBoss ? 110 : (type === 'heavy' ? 80 : 50),
                h: isBoss ? 130 : (type === 'heavy' ? 90 : 70),
                type: isBoss ? 'boss' : type,
                isBoss: isBoss,
                bossType: isBoss ? lvl.bossType : null,
                enemyTier: lvl.enemyTier,
                hp: isBoss ? lvl.bossHp : (type === 'heavy' ? 450 : (type === 'martial' ? 200 : 120)) * (1 + lvlBonus),
                maxHp: isBoss ? lvl.bossHp : 0,
                baseSpeed: isBoss ? (6 * lvl.bossSpeed) : (8 + Math.random() * 6) * (type === 'chaser' ? 1.8 : (type === 'heavy' ? 0.4 : (type === 'martial' ? 0.7 : 0.7))),
                shootTimer: isBoss ? 30 : (40 + Math.random() * 60),
                damageFlash: 0, animPhase: Math.random() * Math.PI * 2,
                aimTimer: 0,
                jumpCooldown: 60 + Math.random() * 120,
                grounded: false,
                martialCombo: 0, martialTimer: 0,
                bulletColor: BULLET_COLORS[Math.floor(Math.random() * BULLET_COLORS.length)],
                color: isBoss ? (BOSS_COLORS[lvl.bossType] || '#ff0000') : tierColors[Math.floor(Math.random() * tierColors.length)]
            };
            enemies.push(e);
        }

        function spawnDrop(x, y) {
            const lvl = LEVELS[currentLevel - 1];
            const comboBonus = combo * 0.005;
            const rand = Math.random();
            const atCap = player.weaponLevel >= lvl.weaponCap;
            const weaponProb = atCap ? 0 : 0.10 + comboBonus;
            const healthProb = 0.08 + (100 - player.hp) * 0.002 + comboBonus;
            const skillProb = 0.15 + comboBonus;

            if (rand < weaponProb) {
                drops.push({ x, y: y - 40, w: 32, h: 32, vy: -10, vx: (Math.random() - 0.5) * 8, type: 'weapon', life: 800 });
            } else if (rand < weaponProb + healthProb) {
                drops.push({ x, y: y - 40, w: 28, h: 28, vy: -12, vx: (Math.random() - 0.5) * 6, type: 'health', life: 800 });
            } else if (rand < weaponProb + healthProb + skillProb) {
                // Random skill drop
                const skillIds = Object.keys(SKILL_DEFS);
                const skillId = skillIds[Math.floor(Math.random() * skillIds.length)];
                drops.push({ x, y: y - 40, w: 30, h: 30, vy: -11, vx: (Math.random() - 0.5) * 7, type: 'skill', skillId, life: 800 });
            }
        }

        function playerShoot() {
            if (player.shootTimer > 0) return;
            const lvl = player.weaponLevel;

            const bDmg = (40 + (lvl * 12)) * (player.ultActive > 0 ? 2 : 1);
            const bSpeed = 45 + (lvl * 1.5);
            const interval = player.ultActive > 0 ? 3 : Math.max(3, 10 - lvl);

            let bColor = '#ff3e3e';
            if (lvl >= 4) bColor = '#a855f7';
            if (lvl >= 7) bColor = '#fbbf24';
            if (lvl >= 10) bColor = NEON_COLORS[gameTime % NEON_COLORS.length];
            if (player.ultActive > 0) bColor = '#ffffff';

            const fire = (vx, vy, sizeMult = 1) => projectiles.push({
                x: player.x + (player.facing === 1 ? player.w : -80),
                y: player.y + 20, vx, vy, owner: 'player',
                color: bColor, life: 50, dmg: bDmg, size: 10 * sizeMult
            });

            if (lvl < 4) {
                fire(player.facing * bSpeed, 0);
            } else if (lvl < 7) {
                fire(player.facing * bSpeed, -4);
                fire(player.facing * bSpeed, 0, 1.2);
                fire(player.facing * bSpeed, 4);
            } else if (lvl < 10) {
                fire(player.facing * bSpeed, -8);
                fire(player.facing * bSpeed, -4);
                fire(player.facing * bSpeed, 0, 1.4);
                fire(player.facing * bSpeed, 4);
                fire(player.facing * bSpeed, 8);
            } else {
                for (let i = -16; i <= 16; i += 4) fire(player.facing * bSpeed, i, i === 0 ? 2.2 : 1.2);
            }

            player.shootTimer = interval;
            playTone(400 + (lvl * 80), 'triangle', 0.05, 0.06);
        }

        // Screen visibility check for enemies
        function isOnScreen(e) {
            const sx = e.x - camX;
            const sy = e.y - camY;
            return sx > -100 && sx < GAME_WIDTH + 100 && sy > -100 && sy < GAME_HEIGHT + 100;
        }

        function update() {
            if (!gameRunning || gamePaused) return;
            if (hitstop > 0) { hitstop--; return; }

            gameTime++;
            if (comboTimer > 0) comboTimer--; else combo = 0;
            if (player.ultActive > 0) player.ultActive--;

            // Level system: check boss spawn
            const lvl = LEVELS[currentLevel - 1];
            if (!bossActive && !bossSpawned && levelKills >= lvl.killTarget) {
                bossActive = true;
                bossSpawned = true;
                spawnEnemy(true);
            }

            spawnCooldown--;
            // Only increase enemy COUNT per level, NOT game speed
            const maxEnemies = bossActive ? 5 : Math.min(15, 5 + currentLevel * 2);
            const spawnRate = bossActive ? 80 : 50; // constant spawn rate
            if (enemies.length < maxEnemies && spawnCooldown <= 0 && !bossSpawned) {
                spawnEnemy();
                spawnCooldown = spawnRate;
            }

            player.animTime += Math.abs(player.vx) * 0.1 + 0.1;
            if (player.dashActive > 0) {
                player.vx = player.facing * DASH_FORCE; player.vy = 0; player.dashActive--;
                trails.push({ x: player.x, y: player.y, w: player.w, h: player.h, life: 0.4, color: player.weaponLevel >= 10 ? NEON_COLORS[gameTime % NEON_COLORS.length] : '#fff', facing: player.facing });
            } else {
                if (keys['KeyA'] || keys['ArrowLeft']) { player.vx = -PLAYER_SPEED; player.facing = -1; }
                else if (keys['KeyD'] || keys['ArrowRight']) { player.vx = PLAYER_SPEED; player.facing = 1; }
                else player.vx *= 0.82;
                player.vy += GRAVITY;
            }
            player.x += player.vx; player.y += player.vy;
            if (player.dashCooldown > 0) player.dashCooldown--;
            if (player.iframe > 0) player.iframe--;

            player.grounded = false;
            platforms.forEach(plt => {
                if (player.x < plt.x + plt.w && player.x + player.w > plt.x && player.y + player.h > plt.y && player.y + player.h < plt.y + plt.h + 20) {
                    if (player.vy > 0) { player.y = plt.y - player.h; player.vy = 0; player.grounded = true; player.jumpCount = 0; }
                }
            });

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dist = player.x - e.x;
                const distY = player.y - e.y;
                const dir = Math.sign(dist);
                e.animPhase += 0.15;
                if (e.damageFlash > 0) e.damageFlash--;

                if (e.type === 'chaser') {
                    e.vx += (dir * e.baseSpeed - e.vx) * 0.12;
                    if (Math.abs(dist) < 60 && Math.abs(distY) < 70) {
                        if (player.iframe <= 0) { player.hp -= (playerSkills.shield.active > 0 ? 8 : 15); player.iframe = 30; }
                        e.hp = 0;
                    }
                } else if (e.type === 'martial') {
                    // Martial arts melee fighter - charges and attacks with kung fu combos
                    e.vx += (dir * e.baseSpeed - e.vx) * 0.15;
                    e.martialTimer++;
                    if (Math.abs(dist) < 80 && Math.abs(distY) < 80) {
                        // Execute martial arts combo
                        if (e.martialTimer > 20) {
                            e.martialCombo = (e.martialCombo + 1) % 4;
                            e.martialTimer = 0;
                            if (player.iframe <= 0) {
                                const rawDmg = (e.martialCombo === 3) ? 25 : 12;
                                player.hp -= playerSkills.shield.active > 0 ? Math.ceil(rawDmg * 0.5) : rawDmg;
                                player.iframe = 20;
                                player.vx += dir * -8;
                                if (e.martialCombo === 3) player.vy = -15;
                                createParticles(player.x, player.y, '#ffa500', 8, 1.5);
                            }
                        }
                    } else {
                        e.martialCombo = 0;
                    }
                } else if (e.type === 'sniper') {
                    if (Math.abs(dist) < 500) e.vx += (-dir * e.baseSpeed - e.vx) * 0.1;
                    else if (Math.abs(dist) > 700) e.vx += (dir * e.baseSpeed - e.vx) * 0.1;
                    e.aimTimer++;
                    if (e.aimTimer > 80 && isOnScreen(e)) {
                        const angle = Math.atan2(distY, dist);
                        const spd = 38;
                        projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd, owner: 'enemy', color: e.bulletColor, life: 100, dmg: 30 });
                        e.aimTimer = 0;
                    }
                } else if (e.type === 'boss') {
                    const bossRage = e.hp < e.maxHp * 0.5;
                    const speedMult = bossRage ? 1.5 : 1.0;
                    e.vx += (dir * e.baseSpeed * speedMult - e.vx) * 0.12;
                    e.shootTimer--;
                    // Rage visual pulse
                    if (bossRage && gameTime % 20 < 3) e.damageFlash = 2;
                    const bt = e.bossType;
                    if (e.shootTimer <= 0 && isOnScreen(e)) {
                        const angle = Math.atan2(distY, dist);
                        const rageCdMult = bossRage ? 0.5 : 1.0;
                        if (bt === 'bandit_chief') {
                            // Charge slam - single heavy shot
                            projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: Math.cos(angle) * 28, vy: Math.sin(angle) * 28, owner: 'enemy', color: '#cc8833', life: 80, dmg: 25, size: 18 });
                            e.shootTimer = 40 * rageCdMult;
                        } else if (bt === 'wolf_king') {
                            // Triple claw swipe
                            for (let a = -0.2; a <= 0.2; a += 0.2) {
                                projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: Math.cos(angle + a) * 24, vy: Math.sin(angle + a) * 24, owner: 'enemy', color: '#aaaaaa', life: 60, dmg: 15 });
                            }
                            e.shootTimer = 30 * rageCdMult;
                        } else if (bt === 'iron_fist') {
                            // Ground pound - 4 shockwaves left/right
                            for (let s = -1; s <= 1; s += 2) {
                                projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h, vx: s * 18, vy: -4, owner: 'enemy', color: '#ff8800', life: 80, dmg: 20, size: 16 });
                                projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h, vx: s * 12, vy: -8, owner: 'enemy', color: '#ffaa33', life: 80, dmg: 15 });
                            }
                            e.shootTimer = 35 * rageCdMult;
                        } else if (bt === 'shield_general') {
                            // Shield bash + 2 side shots
                            projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: Math.cos(angle) * 20, vy: Math.sin(angle) * 20, owner: 'enemy', color: '#4488cc', life: 100, dmg: 30, size: 20 });
                            for (let a = -0.5; a <= 0.5; a += 1) {
                                projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: Math.cos(angle + a) * 16, vy: Math.sin(angle + a) * 16, owner: 'enemy', color: '#66aaee', life: 80, dmg: 10 });
                            }
                            e.shootTimer = 45 * rageCdMult;
                        } else if (bt === 'phantom_archer') {
                            // Arrow rain - 5 shots arcing down
                            for (let i = -2; i <= 2; i++) {
                                projectiles.push({ x: e.x + e.w / 2 + i * 30, y: e.y, vx: i * 4, vy: -20, owner: 'enemy', color: '#33cc99', life: 120, dmg: 12 });
                            }
                            e.shootTimer = 28 * rageCdMult;
                        } else if (bt === 'twin_blade') {
                            // X-slash pattern
                            for (let a = 0; a < Math.PI * 2; a += Math.PI / 2) {
                                projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: Math.cos(a) * 22, vy: Math.sin(a) * 22, owner: 'enemy', color: '#cc44cc', life: 80, dmg: 18 });
                            }
                            e.shootTimer = 22 * rageCdMult;
                        } else if (bt === 'thunder_monk') {
                            // Lightning ring - 8 directions
                            for (let a = 0; a < Math.PI * 2; a += Math.PI / 4) {
                                projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: Math.cos(a) * 18, vy: Math.sin(a) * 18, owner: 'enemy', color: '#ffcc00', life: 90, dmg: 15 });
                            }
                            e.shootTimer = 30 * rageCdMult;
                        } else if (bt === 'blood_demon') {
                            // Spiral blood shots
                            const spin = gameTime * 0.1;
                            for (let i = 0; i < 3; i++) {
                                const sa = spin + i * Math.PI * 2 / 3;
                                projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: Math.cos(sa) * 20, vy: Math.sin(sa) * 20, owner: 'enemy', color: '#cc0000', life: 100, dmg: 18 });
                            }
                            e.shootTimer = 18 * rageCdMult;
                        } else if (bt === 'shadow_lord') {
                            // Shadow split - aimed + 2 flanking
                            projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: Math.cos(angle) * 30, vy: Math.sin(angle) * 30, owner: 'enemy', color: '#6633cc', life: 90, dmg: 25, size: 16 });
                            for (let d = -1; d <= 1; d += 2) {
                                projectiles.push({ x: e.x + e.w / 2 + d * 60, y: e.y, vx: Math.cos(angle) * 22, vy: Math.sin(angle) * 22, owner: 'enemy', color: '#9966ff', life: 80, dmg: 12 });
                            }
                            e.shootTimer = 20 * rageCdMult;
                        } else { // sword_saint
                            // 12-direction blade storm
                            for (let a = 0; a < Math.PI * 2; a += Math.PI / 6) {
                                projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: Math.cos(a) * 24, vy: Math.sin(a) * 24, owner: 'enemy', color: '#ffffff', life: 80, dmg: 15 });
                            }
                            e.shootTimer = 25 * rageCdMult;
                        }
                    }
                    // Boss melee slam
                    if (Math.abs(dist) < 100 && Math.abs(distY) < 100 && player.iframe <= 0) {
                        player.hp -= playerSkills.shield.active > 0 ? 10 : 20; player.iframe = 40;
                        player.vx += dir * -15; player.vy = -10;
                        createParticles(player.x, player.y, e.color, 10, 2);
                        haptic('heavy');
                    }
                } else {
                    e.vx += (dir * e.baseSpeed - e.vx) * 0.1;
                }

                // Enemy jumping ability
                e.jumpCooldown--;
                if (e.grounded && e.jumpCooldown <= 0 && (distY < -80 || Math.random() < 0.01)) {
                    e.vy = -20 - Math.random() * 8;
                    e.jumpCooldown = 80 + Math.random() * 120;
                }

                e.vy += GRAVITY; e.x += e.vx; e.y += e.vy;
                e.grounded = false;
                platforms.forEach(plt => {
                    if (e.x < plt.x + plt.w && e.x + e.w > plt.x && e.y + e.h > plt.y && e.y + e.h < plt.y + plt.h + 20) {
                        if (e.vy > 0) { e.y = plt.y - e.h; e.vy = 0; e.grounded = true; }
                    }
                });

                // 360¬∞ shooting for scout and heavy - ONLY when on screen
                if (e.type !== 'chaser' && e.type !== 'sniper' && e.type !== 'martial' && e.type !== 'boss') {
                    e.shootTimer--;
                    if (e.shootTimer <= 0 && isOnScreen(e)) {
                        const angle = Math.atan2(distY, dist);
                        const spd = 14;
                        projectiles.push({ x: e.x + e.w / 2, y: e.y + e.h / 2, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd, owner: 'enemy', color: e.bulletColor, life: 120, dmg: 12 });
                        e.shootTimer = 70 + Math.random() * 50;
                    }
                }

                if (e.hp <= 0) {
                    const wasBoss = e.isBoss;
                    enemies.splice(i, 1); kills++; levelKills++; combo++; comboTimer = 150; hitstop = wasBoss ? 12 : 4;
                    player.energy = Math.min(100, player.energy + (wasBoss ? 50 : 4));
                    createParticles(e.x + e.w / 2, e.y + e.h / 2, e.color, wasBoss ? 25 : 8, wasBoss ? 2 : 1.2, wasBoss ? 3 : 2);
                    spawnDrop(e.x + e.w / 2, e.y + e.h / 2);
                    playTone(60, 'sine', 0.1, 0.3);
                    haptic(wasBoss ? 'heavy' : 'medium');
                    // Boss killed = level complete
                    if (wasBoss) {
                        bossActive = false;
                        if (currentLevel < 10) {
                            completeLevel();
                        } else {
                            // Game won!
                            endGame(true);
                        }
                    }
                }
            }

            for (let i = drops.length - 1; i >= 0; i--) {
                const d = drops[i]; d.vy += GRAVITY * 0.6; d.x += d.vx; d.y += d.vy; d.life--;

                platforms.forEach(plt => {
                    if (d.x < plt.x + plt.w && d.x + d.w > plt.x && d.y + d.h > plt.y && d.y + d.h < plt.y + plt.h + 20) {
                        if (d.vy > 0) {
                            d.y = plt.y - d.h;
                            d.vy = 0;
                            d.vx *= 0.7;
                        }
                    }
                });

                if (Math.abs(d.x - player.x) < 50 && Math.abs(d.y - player.y) < 70) {
                    if (d.type === 'health') { player.hp = Math.min(100, player.hp + 30); playTone(800, 'sine', 0.2, 0.2); }
                    else if (d.type === 'weapon') {
                        const cap = LEVELS[currentLevel - 1].weaponCap;
                        if (player.weaponLevel < cap) {
                            player.weaponLevel++;
                            playTone(1200, 'square', 0.4, 0.2);
                            createParticles(player.x, player.y, '#fbbf24', 15, 2);
                        }
                    } else if (d.type === 'skill') {
                        const sk = playerSkills[d.skillId];
                        if (sk && sk.level < 10) {
                            sk.level++;
                            playTone(600 + sk.level * 100, 'square', 0.3, 0.25);
                            createParticles(player.x, player.y, SKILL_DEFS[d.skillId].color, 20, 2);
                        } else {
                            // Max level - give energy instead
                            player.energy = Math.min(100, player.energy + 10);
                        }
                    }
                    drops.splice(i, 1); continue;
                }
                if (d.life <= 0) drops.splice(i, 1);
            }

            // Manual attack: shoot when holding KeyJ
            if (keys['KeyJ']) playerShoot();
            if (player.shootTimer > 0) player.shootTimer--;

            // Skill cooldowns & shield active
            for (const sk of Object.values(playerSkills)) {
                if (sk.cooldown > 0) sk.cooldown--;
                if (sk.active !== undefined && sk.active > 0) sk.active--;
            }

            // Send skill cooldown to native buttons (every 10 frames for performance)
            if (gameTime % 10 === 0 && window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.skillCooldown) {
                const skillIds = Object.keys(SKILL_DEFS);
                for (let si = 0; si < skillIds.length; si++) {
                    const sk = playerSkills[skillIds[si]];
                    const def = SKILL_DEFS[skillIds[si]];
                    const maxCd = Math.max(40, def.baseCd - sk.level * 8);
                    const ratio = sk.level > 0 ? (sk.cooldown / maxCd) : 0;
                    const seconds = sk.level > 0 ? (sk.cooldown / 60) : 0;
                    try { window.webkit.messageHandlers.skillCooldown.postMessage({ index: si, ratio: ratio, seconds: seconds, level: sk.level }); } catch (e) { }
                }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const pj = projectiles[i];
                // Homing logic
                if (pj.homing && pj.owner === 'player' && enemies.length > 0) {
                    let closest = null, minDist = 999999;
                    enemies.forEach(e => {
                        const d = Math.hypot(e.x - pj.x, e.y - pj.y);
                        if (d < minDist) { minDist = d; closest = e; }
                    });
                    if (closest) {
                        const a = Math.atan2(closest.y + closest.h / 2 - pj.y, closest.x + closest.w / 2 - pj.x);
                        const spd = Math.hypot(pj.vx, pj.vy);
                        pj.vx += Math.cos(a) * 2;
                        pj.vy += Math.sin(a) * 2;
                        const ns = Math.hypot(pj.vx, pj.vy);
                        pj.vx = pj.vx / ns * spd;
                        pj.vy = pj.vy / ns * spd;
                    }
                }
                pj.x += pj.vx; pj.y += pj.vy; pj.life--;
                if (pj.owner === 'player') {
                    enemies.forEach(e => {
                        if (pj.x < e.x + e.w && pj.x + 70 > e.x && pj.y < e.y + e.h && pj.y + pj.size > e.y) {
                            e.hp -= pj.dmg; pj.life = 0; e.damageFlash = 6;
                            createParticles(pj.x, pj.y, pj.color, 4);
                            haptic('light'); // hit feedback
                        }
                    });
                } else if (player.iframe <= 0 && pj.x < player.x + player.w && pj.x + 20 > player.x && pj.y < player.y + player.h && pj.y + 15 > player.y) {
                    const finalDmg = playerSkills.shield.active > 0 ? Math.ceil(pj.dmg * 0.5) : pj.dmg;
                    player.hp -= finalDmg; player.iframe = 35; pj.life = 0;
                    createParticles(player.x + player.w / 2, player.y + player.h / 2, '#f00', 15);
                    haptic('heavy'); // player hit feedback
                }
                if (pj.life <= 0) projectiles.splice(i, 1);
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const pt = particles[i]; pt.x += pt.vx; pt.y += pt.vy; pt.life -= pt.decay;
                if (pt.life <= 0) particles.splice(i, 1);
            }
            for (let i = trails.length - 1; i >= 0; i--) {
                const t = trails[i]; t.life -= 0.1; if (t.life <= 0) trails.splice(i, 1);
            }

            camX += (player.x - canvas.width / 3.5 - camX) * 0.12;
            camY += (player.y - canvas.height / 2 - camY) * 0.1;

            ui.hp.style.width = player.hp + '%';
            ui.ult.style.width = player.energy + '%';
            ui.kills.innerText = `Êñ©Êïå: ${kills}`;
            if (combo > 1) { ui.combo.innerText = `${combo} ËøûÊñ©`; ui.comboContainer.style.opacity = 1; }
            else ui.comboContainer.style.opacity = 0;

            const realms = ["ÂàùÂÖ•Ê±üÊπñ", "ÁÇº‰Ωì", "Á≠ëÂü∫", "Èáë‰∏π", "ÂÖÉÂ©¥", "ÂåñÁ•û", "Âêà‰Ωì", "Â§ß‰πò", "Ê∏°Âä´", "ÂâëÁ•ûÂúÜÊª°"];
            ui.rank.innerText = `Â¢ÉÁïåÔºö${realms[player.weaponLevel - 1]} [Lv.${player.weaponLevel}]`;
            // Level progress display (reuse lvl from above)
            if (bossActive) {
                document.getElementById('level-display').innerText = `${lvl.name} ‚Äî BOSSÊàòÔºÅ`;
            } else if (bossSpawned) {
                document.getElementById('level-display').innerText = `${lvl.name}`;
            } else {
                document.getElementById('level-display').innerText = `${lvl.name}  [${levelKills}/${lvl.killTarget}]`;
            }

            if (player.hp <= 0 || player.y > 2500) endGame(false);
        }

        // Draw ink wash background with mountains
        function drawInkWashBg() {
            // Sky gradient - rice paper tone
            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, '#e8dcc8');
            grad.addColorStop(0.3, '#d8ccb4');
            grad.addColorStop(0.6, '#c8b89a');
            grad.addColorStop(1, '#b0a080');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Distant mountains - layered ink wash
            const mtnOffset = camX * 0.05;
            ctx.globalAlpha = 0.15;
            for (let layer = 0; layer < 3; layer++) {
                const ly = 200 + layer * 120;
                const speed = 0.02 + layer * 0.015;
                ctx.fillStyle = ['#4a4a4a', '#6a6a6a', '#8a8a7a'][layer];
                ctx.beginPath();
                ctx.moveTo(0, ly + 200);
                for (let x = 0; x <= canvas.width; x += 40) {
                    const h = Math.sin((x + camX * speed) * 0.003 + layer) * 80 + Math.sin((x + camX * speed) * 0.007 + layer * 2) * 40;
                    ctx.lineTo(x, ly - h);
                }
                ctx.lineTo(canvas.width, ly + 200);
                ctx.closePath();
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
            // Floating ink particles (mist)
            ctx.globalAlpha = 0.06;
            for (let i = 0; i < 8; i++) {
                const mx = ((gameTime * 0.3 + i * 200) % (canvas.width + 200)) - 100;
                const my = 100 + Math.sin(gameTime * 0.01 + i) * 60 + i * 50;
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.arc(mx, my, 40 + i * 10, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        function draw() {
            drawInkWashBg();
            ctx.save(); ctx.translate(-camX, -camY);

            platforms.forEach(plt => {
                if (plt.x + plt.w < camX - 400 || plt.x > camX + canvas.width + 400) return;
                // Ink wash platform style
                ctx.fillStyle = plt.color;
                ctx.fillRect(plt.x, plt.y, plt.w, plt.h);
                // Brush stroke top edge
                ctx.strokeStyle = plt.isGround ? '#8a7a60' : '#706050';
                ctx.lineWidth = plt.isGround ? 3 : 2;
                ctx.beginPath();
                ctx.moveTo(plt.x, plt.y);
                for (let bx = plt.x; bx <= plt.x + plt.w; bx += 8) {
                    ctx.lineTo(bx, plt.y + Math.sin(bx * 0.1) * 1.5);
                }
                ctx.stroke();
                // Subtle shadow under floating platforms
                if (!plt.isGround) {
                    ctx.fillStyle = 'rgba(0,0,0,0.08)';
                    ctx.fillRect(plt.x + 5, plt.y + plt.h, plt.w - 10, 4);
                }
            });

            drops.forEach(d => {
                ctx.save(); ctx.translate(d.x + d.w / 2, d.y + d.h / 2 + Math.sin(gameTime * 0.1) * 10);
                if (d.type === 'health') {
                    ctx.shadowBlur = 20; ctx.shadowColor = '#22c55e'; ctx.fillStyle = '#22c55e';
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.arc(-6, -6, 8, 0, Math.PI, true); ctx.arc(6, -6, 8, 0, Math.PI, true); ctx.lineTo(0, 10); ctx.fill();
                } else if (d.type === 'skill') {
                    const skDef = SKILL_DEFS[d.skillId];
                    ctx.shadowBlur = 20; ctx.shadowColor = skDef.color; ctx.fillStyle = skDef.color;
                    ctx.beginPath(); ctx.arc(0, 0, 14 + Math.sin(gameTime * 0.15) * 3, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.font = '14px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(skDef.emoji, 0, 0);
                } else {
                    ctx.shadowBlur = 25; ctx.shadowColor = '#fbbf24'; ctx.fillStyle = '#fbbf24';
                    ctx.rotate(gameTime * 0.05); ctx.fillRect(-16, -16, 32, 32);
                    ctx.fillStyle = '#fff'; ctx.fillRect(-4, -12, 8, 24); ctx.fillRect(-12, -4, 24, 8);
                }
                ctx.restore();
            });

            if (player.iframe % 4 < 2) {
                drawPlayer(player.x, player.y, player.w, player.h, player.facing, player.animTime);
                // Shield visual
                if (playerSkills.shield.active > 0) {
                    ctx.save();
                    ctx.strokeStyle = '#ffcc00';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.4 + Math.sin(gameTime * 0.2) * 0.2;
                    ctx.beginPath();
                    ctx.arc(player.x + player.w / 2, player.y + player.h / 2, 45, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            enemies.forEach(e => {
                drawPixelStickman(e);
            });

            projectiles.forEach(pj => {
                ctx.save();
                ctx.fillStyle = pj.color; ctx.shadowBlur = 15; ctx.shadowColor = pj.color;
                if (pj.owner === 'enemy') {
                    // Colorful circular enemy bullets
                    ctx.beginPath();
                    ctx.arc(pj.x, pj.y, (pj.size || 10) / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.arc(pj.x, pj.y, (pj.size || 10), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else {
                    ctx.fillRect(pj.x, pj.y, 70, pj.size || 10);
                }
                ctx.restore();
            });

            // Performance: batch particle draw
            for (let i = 0; i < particles.length; i++) {
                const pt = particles[i];
                ctx.globalAlpha = pt.life;
                ctx.fillStyle = pt.color;
                ctx.fillRect(pt.x, pt.y, pt.size, pt.size);
            }
            ctx.restore();

            // Draw boss HP bar
            enemies.forEach(e => {
                if (e.isBoss && e.maxHp > 0) {
                    const bx = e.x - camX;
                    const by = e.y - camY - 20;
                    ctx.save();
                    ctx.fillStyle = '#333';
                    ctx.fillRect(bx - 10, by, e.w + 20, 8);
                    const rage = e.hp < e.maxHp * 0.5;
                    ctx.fillStyle = rage ? '#ff4400' : '#ff0000';
                    ctx.fillRect(bx - 10, by, (e.w + 20) * (e.hp / e.maxHp), 8);
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px sans-serif';
                    ctx.fillText(rage ? 'BOSS ÁãÇÊö¥!' : 'BOSS', bx + e.w / 2 - 16, by - 4);
                    ctx.restore();
                }
            });

            // Draw skill HUD on canvas (bottom-left above joystick)
            ctx.save();
            ctx.globalAlpha = 0.9;
            let skX = 20;
            const skY = canvas.height - 50;
            for (const [id, def] of Object.entries(SKILL_DEFS)) {
                const sk = playerSkills[id];
                if (sk.level <= 0) { skX += 50; continue; }
                // Background
                ctx.fillStyle = sk.cooldown > 0 ? 'rgba(40,35,28,0.6)' : 'rgba(40,35,28,0.3)';
                ctx.fillRect(skX, skY, 44, 44);
                ctx.strokeStyle = def.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(skX, skY, 44, 44);
                // Cooldown overlay
                if (sk.cooldown > 0) {
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    const cdRatio = sk.cooldown / Math.max(40, def.baseCd - sk.level * 8);
                    ctx.fillRect(skX, skY, 44, 44 * cdRatio);
                }
                // Emoji + level
                ctx.fillStyle = '#fff';
                ctx.font = '18px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(def.emoji, skX + 22, skY + 22);
                ctx.font = '10px sans-serif';
                ctx.fillStyle = def.color;
                ctx.fillText('Lv' + sk.level, skX + 22, skY + 40);
                skX += 50;
            }
            ctx.restore();

            if (!gameLoopRunning) {
                gameLoopRunning = true;
                requestAnimationFrame(() => {
                    gameLoopRunning = false;
                    if (gameRunning) { update(); draw(); }
                });
            }
        }

        function drawPlayer(x, y, w, h, facing, anim) {
            ctx.save(); ctx.translate(x + w / 2, y + h / 2); ctx.scale(facing, 1);
            const lvl = player.weaponLevel;
            const bob = Math.sin(anim) * 5;

            if (lvl >= 10) {
                for (let i = 0; i < 8; i++) {
                    const ang = gameTime * 0.1 + (i / 8) * Math.PI * 2;
                    ctx.save(); ctx.translate(Math.cos(ang) * 55, Math.sin(ang) * 55);
                    ctx.rotate(ang + Math.PI / 2);
                    ctx.fillStyle = NEON_COLORS[(gameTime + i) % NEON_COLORS.length];
                    ctx.fillRect(-2, -18, 4, 36); ctx.restore();
                }
            }

            let cloakColor = '#222';
            if (lvl >= 4) cloakColor = '#312e81';
            if (lvl >= 7) cloakColor = '#4c1d95';
            if (lvl >= 10) cloakColor = NEON_COLORS[gameTime % NEON_COLORS.length];

            ctx.fillStyle = cloakColor;
            ctx.beginPath(); ctx.moveTo(0, -10);
            ctx.quadraticCurveTo(-30 - (lvl * 3), bob, 0, h / 2 + bob); ctx.fill();

            ctx.fillStyle = lvl >= 7 ? '#fff' : '#eee';
            ctx.fillRect(-10, -10, 20, 40);

            ctx.fillStyle = lvl >= 7 ? '#fbbf24' : '#444';
            ctx.beginPath(); ctx.moveTo(-25 - (lvl * 1.2), -15); ctx.lineTo(0, -30 - (lvl / 1.5)); ctx.lineTo(25 + (lvl * 1.2), -15); ctx.closePath(); ctx.fill();
            if (lvl >= 10) {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                ctx.shadowBlur = 20; ctx.shadowColor = '#fff';
            }

            ctx.strokeStyle = lvl >= 10 ? NEON_COLORS[gameTime % NEON_COLORS.length] : (lvl >= 7 ? '#fbbf24' : '#fff');
            ctx.lineWidth = 3 + lvl / 2.5;
            ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(35 + lvl * 2.5, 10); ctx.stroke();

            ctx.restore();
        }

        function drawPixelStickman(e) {
            ctx.save(); ctx.translate(e.x + e.w / 2, e.y + e.h / 2);
            ctx.scale(Math.sign(player.x - e.x) || 1, 1);
            const hover = Math.sin(e.animPhase) * 6; ctx.translate(0, hover);

            let color = e.color;
            if (e.damageFlash > 0) color = '#fff';

            ctx.strokeStyle = color; ctx.lineWidth = e.type === 'heavy' ? 8 : (e.isBoss ? 6 : 4);
            ctx.lineCap = 'round'; ctx.shadowBlur = 12; ctx.shadowColor = color;

            const t = e.animPhase;
            const tier = e.enemyTier || 1;

            if (e.isBoss) {
                // === UNIQUE BOSS DRAWINGS ===
                const bt = e.bossType;
                // All bosses: larger head
                ctx.strokeRect(-14, -e.h / 2, 28, 28);
                // Body
                ctx.beginPath(); ctx.moveTo(0, -e.h / 2 + 28); ctx.lineTo(0, 10); ctx.stroke();
                const hs = Math.sin(t) * 15;
                // Legs
                ctx.beginPath(); ctx.moveTo(0, 10); ctx.lineTo(18, 30 + Math.cos(t) * 10); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, 10); ctx.lineTo(-18, 30 - Math.cos(t) * 10); ctx.stroke();

                if (bt === 'bandit_chief') {
                    // Straw hat + large club
                    ctx.fillStyle = color; ctx.fillRect(-20, -e.h / 2 - 6, 40, 6);
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(30, hs); ctx.lineTo(35, hs - 5); ctx.stroke();
                    ctx.lineWidth = 8; ctx.beginPath(); ctx.moveTo(30, hs); ctx.lineTo(40, hs + 5); ctx.stroke();
                } else if (bt === 'wolf_king') {
                    // Wolf ears + claws
                    ctx.beginPath(); ctx.moveTo(-10, -e.h / 2); ctx.lineTo(-15, -e.h / 2 - 15); ctx.lineTo(-5, -e.h / 2); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(10, -e.h / 2); ctx.lineTo(15, -e.h / 2 - 15); ctx.lineTo(5, -e.h / 2); ctx.stroke();
                    // Claws on hands
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(20, hs); ctx.stroke();
                    for (let c = 0; c < 3; c++) ctx.fillRect(18 + c * 4, hs - 2, 2, 8);
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(-20, -hs); ctx.stroke();
                    for (let c = 0; c < 3; c++) ctx.fillRect(-20 - c * 4, -hs - 2, 2, 8);
                } else if (bt === 'iron_fist') {
                    // Headband + giant fists
                    ctx.fillStyle = '#ff4400'; ctx.fillRect(-18, -e.h / 2 + 2, 36, 5);
                    ctx.lineWidth = 10;
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(25, hs); ctx.stroke();
                    ctx.fillRect(20, hs - 8, 16, 16);
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(-25, -hs); ctx.stroke();
                    ctx.fillRect(-36, -hs - 8, 16, 16);
                } else if (bt === 'shield_general') {
                    // Helmet + shield
                    ctx.fillStyle = color; ctx.fillRect(-16, -e.h / 2 - 8, 32, 8);
                    ctx.fillRect(-2, -e.h / 2 - 14, 4, 10);
                    // Shield on left arm
                    ctx.lineWidth = 3; ctx.strokeRect(-30, -15, 18, 30);
                    ctx.fillStyle = color; ctx.globalAlpha = 0.3; ctx.fillRect(-30, -15, 18, 30); ctx.globalAlpha = 1;
                    // Spear on right
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(35, hs - 10); ctx.stroke();
                } else if (bt === 'phantom_archer') {
                    // Hood + bow
                    ctx.beginPath(); ctx.moveTo(-15, -e.h / 2 + 5); ctx.lineTo(0, -e.h / 2 - 12); ctx.lineTo(15, -e.h / 2 + 5); ctx.stroke();
                    // Bow
                    ctx.beginPath(); ctx.arc(20, 0, 20, -Math.PI / 3, Math.PI / 3); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(20, -10); ctx.lineTo(20, 10); ctx.stroke();
                } else if (bt === 'twin_blade') {
                    // Two swords
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(25, hs - 15); ctx.lineTo(28, hs - 20); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(-25, -hs - 15); ctx.lineTo(-28, -hs - 20); ctx.stroke();
                    // Flowing scarf
                    ctx.strokeStyle = '#ff66ff'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(-14, -e.h / 2 + 10);
                    ctx.bezierCurveTo(-25, -e.h / 2 + 5, -35 - Math.sin(t * 2) * 10, -e.h / 2 + 15, -40 - Math.sin(t * 3) * 8, -e.h / 2 + 5);
                    ctx.stroke(); ctx.strokeStyle = color;
                } else if (bt === 'thunder_monk') {
                    // Bald head + prayer beads + lightning
                    ctx.fillStyle = color; ctx.beginPath(); ctx.arc(0, -e.h / 2 + 14, 14, 0, Math.PI * 2); ctx.fill();
                    // Prayer beads
                    ctx.fillStyle = '#ffcc00';
                    for (let b = 0; b < 8; b++) {
                        const ba = b * Math.PI / 4;
                        ctx.beginPath(); ctx.arc(Math.cos(ba) * 12, Math.sin(ba) * 12 - e.h / 2 + 14, 3, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(15, hs); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(-15, -hs); ctx.stroke();
                    // Lightning effect
                    if (Math.random() > 0.7) {
                        ctx.strokeStyle = '#ffcc00'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(e.w / 2, -e.h / 2); ctx.lineTo(e.w / 2 + 10, -e.h / 2 - 20); ctx.lineTo(e.w / 2 + 5, -e.h / 2 - 15); ctx.lineTo(e.w / 2 + 15, -e.h / 2 - 35); ctx.stroke();
                    }
                } else if (bt === 'blood_demon') {
                    // Horns + tail + red aura
                    ctx.beginPath(); ctx.moveTo(-10, -e.h / 2); ctx.lineTo(-18, -e.h / 2 - 18); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(10, -e.h / 2); ctx.lineTo(18, -e.h / 2 - 18); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(20, hs); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(-20, -hs); ctx.stroke();
                    // Tail
                    ctx.beginPath(); ctx.moveTo(0, 10); ctx.bezierCurveTo(-20, 20, -30, 10 + Math.sin(t) * 10, -35, 0); ctx.stroke();
                    // Aura
                    ctx.strokeStyle = '#cc0000'; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
                    ctx.beginPath(); ctx.arc(0, 0, 35 + Math.sin(t * 2) * 5, 0, Math.PI * 2); ctx.stroke();
                    ctx.globalAlpha = 1;
                } else if (bt === 'shadow_lord') {
                    // Hooded figure + shadow tendrils
                    ctx.beginPath(); ctx.moveTo(-18, -e.h / 2 + 10); ctx.lineTo(0, -e.h / 2 - 15); ctx.lineTo(18, -e.h / 2 + 10); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(15, hs); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(-15, -hs); ctx.stroke();
                    // Shadow tendrils
                    ctx.strokeStyle = '#6633cc'; ctx.lineWidth = 2;
                    for (let td = 0; td < 4; td++) {
                        const ta = td * Math.PI / 2 + t * 0.5;
                        ctx.beginPath(); ctx.moveTo(0, 10);
                        ctx.bezierCurveTo(Math.cos(ta) * 20, 20 + Math.sin(ta) * 10, Math.cos(ta) * 30, 30, Math.cos(ta) * 35, 25 + Math.sin(ta + 1) * 10);
                        ctx.stroke();
                    }
                } else { // sword_saint
                    // Crown + glowing sword + cape
                    ctx.fillStyle = '#ffcc00';
                    ctx.fillRect(-12, -e.h / 2 - 4, 24, 4);
                    for (let p = -8; p <= 8; p += 8) ctx.fillRect(p - 2, -e.h / 2 - 10, 4, 8);
                    // Sword
                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(35, hs - 10); ctx.lineTo(38, hs - 20); ctx.stroke();
                    ctx.strokeStyle = color;
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(-15, -hs); ctx.stroke();
                    // Cape
                    ctx.fillStyle = color; ctx.globalAlpha = 0.3;
                    ctx.beginPath(); ctx.moveTo(-14, -e.h / 2 + 28); ctx.lineTo(-20, 30); ctx.lineTo(20, 30); ctx.lineTo(14, -e.h / 2 + 28); ctx.fill();
                    ctx.globalAlpha = 1;
                    // Glow
                    ctx.shadowBlur = 25; ctx.shadowColor = '#ffffff';
                }
            } else if (e.type === 'martial') {
                // Chinese martial arts stance drawing
                const combo = e.martialCombo || 0;
                ctx.strokeRect(-10, -e.h / 2, 20, 20);
                // Headband color by tier
                ctx.fillStyle = tier === 3 ? '#cc0000' : (tier === 2 ? '#4488cc' : '#ff4444');
                ctx.fillRect(-14, -e.h / 2, 28, 4);
                ctx.beginPath(); ctx.moveTo(0, -e.h / 2 + 20); ctx.lineTo(0, 5); ctx.stroke();
                if (combo === 0) {
                    ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(25, -15); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(-15, 0); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(20, 25); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(-20, 25); ctx.stroke();
                } else if (combo === 1) {
                    ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(-10, -25); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(-20, 5); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(35, 5); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(-10, 30); ctx.stroke();
                } else if (combo === 2) {
                    const sw = Math.sin(t * 3) * 30;
                    ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(10 + sw, -20); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(-10 - sw, -20); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(25 + sw, 20); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(-25 - sw, 20); ctx.stroke();
                } else {
                    ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(5, -35); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(20, -5); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(10, 30); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(-10, 30); ctx.stroke();
                    ctx.strokeStyle = tier === 3 ? '#cc0000' : '#ffa500'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(5, -30, 8, 0, Math.PI * 2); ctx.stroke();
                }
            } else {
                // Normal enemies with tier-based accessories
                ctx.strokeRect(-10, -e.h / 2, 20, 20);
                ctx.beginPath(); ctx.moveTo(0, -e.h / 2 + 20); ctx.lineTo(0, 5); ctx.stroke();
                const handSwing = Math.sin(t) * 20;
                ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(15, handSwing); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(-15, -handSwing); ctx.stroke();
                const legSwing = Math.cos(t) * 20;
                ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(15, 25 + legSwing); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(-15, 25 - legSwing); ctx.stroke();

                if (e.type === 'scout') { ctx.fillStyle = color; ctx.fillRect(15, handSwing - 5, 20, 5); }
                if (e.type === 'heavy') { ctx.strokeRect(10, -20, 15, 50); }

                // Tier accessories
                if (tier === 1) {
                    // Straw hat
                    ctx.fillStyle = color; ctx.globalAlpha = 0.4;
                    ctx.fillRect(-14, -e.h / 2 - 3, 28, 3);
                    ctx.globalAlpha = 1;
                } else if (tier === 2) {
                    // Helmet with plume
                    ctx.fillStyle = color;
                    ctx.fillRect(-12, -e.h / 2 - 5, 24, 5);
                    ctx.fillRect(0, -e.h / 2 - 12, 3, 8);
                    // Shoulder pads
                    ctx.fillRect(-18, -10, 6, 6);
                    ctx.fillRect(12, -10, 6, 6);
                } else {
                    // Full armor + glowing eyes
                    ctx.fillStyle = color;
                    ctx.fillRect(-14, -e.h / 2 - 6, 28, 6);
                    ctx.fillRect(-2, -e.h / 2 - 14, 4, 10);
                    // Shoulder armor
                    ctx.fillRect(-22, -12, 10, 8);
                    ctx.fillRect(12, -12, 10, 8);
                    // Glowing eyes
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(-7, -e.h / 2 + 5, 4, 3);
                    ctx.fillRect(3, -e.h / 2 + 5, 4, 3);
                }
            }

            ctx.restore();
        }

        // Keep keyboard support for debugging
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (!gameRunning) return;
            if ((e.code === 'KeyJ' || e.code === 'Space') && player.jumpCount < 2) {
                player.vy = JUMP_FORCE; player.jumpCount++; playTone(400, 'sine', 0.1, 0.1);
            }
            if ((e.code === 'ShiftLeft' || e.code === 'KeyW') && player.dashCooldown <= 0) {
                player.dashActive = 15; player.dashCooldown = 35; playTone(300, 'triangle', 0.1, 0.1);
            }
            if (e.code === 'KeyL' && player.energy >= 100) {
                player.energy = 0; player.ultActive = 240; player.iframe = 240;
                playTone(100, 'sawtooth', 1.0, 0.5);
                createParticles(player.x, player.y, '#fff', 50, 3);
            }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        function startGame() {
            ui.menu.classList.add('hidden'); ui.hud.classList.add('visible');
            currentLevel = 1; levelKills = 0; bossActive = false; bossSpawned = false;
            initPlatforms(); gameRunning = true; gamePaused = false; resize();
            showLevelBanner();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            BGM.start();
        }
        window.startGame = startGame;

        function endGame(won) {
            gameRunning = false; ui.hud.classList.remove('visible'); ui.over.classList.add('visible');
            if (won) {
                document.querySelector('#game-over h1').innerText = 'Â§©‰∏ãÊó†Êïå';
                ui.stats.innerText = `ÈÄöÂÖ≥ÔºÅÊñ©Êïå: ${kills} | ÊúÄÁªàÂ¢ÉÁïå: Lv.${player.weaponLevel}`;
            } else {
                document.querySelector('#game-over h1').innerText = 'Ê∞îÂ∞Ω‰∫∫‰∫°';
                ui.stats.innerText = `Á¨¨${currentLevel}ÂÖ≥ËêΩË¥• | Êñ©Êïå: ${kills} | Â¢ÉÁïå: Lv.${player.weaponLevel}`;
            }
            BGM.stop();
            haptic('error');
        }

        function completeLevel() {
            gamePaused = true;
            currentLevel++;
            levelKills = 0;
            bossSpawned = false;
            bossActive = false;
            // Heal player between levels
            player.hp = Math.min(100, player.hp + 30);
            // Clear remaining enemies
            enemies.length = 0;
            projectiles.length = 0;
            showLevelBanner();
        }

        function showLevelBanner() {
            const lvl = LEVELS[currentLevel - 1];
            const banner = document.getElementById('level-banner');
            document.getElementById('level-title').innerText = lvl.name;
            document.getElementById('level-subtitle').innerText = `Ê≠¶Âô®‰∏äÈôê: Lv.${lvl.weaponCap} | ÂáªÊùÄÁõÆÊ†á: ${lvl.killTarget}`;
            banner.classList.add('visible');
            setTimeout(() => {
                banner.classList.remove('visible');
                gamePaused = false;
                if (!gameLoopRunning) draw();
            }, 2000);
        }

        function togglePause() {
            if (!gameRunning) return;
            gamePaused = !gamePaused;
            const overlay = document.getElementById('pause-overlay');
            if (gamePaused) {
                overlay.classList.add('visible');
            } else {
                overlay.classList.remove('visible');
                if (!gameLoopRunning) draw();
            }
        }
        window.togglePause = togglePause;

        function returnHome() {
            gameRunning = false;
            gamePaused = false;
            BGM.stop();
            document.getElementById('pause-overlay').classList.remove('visible');
            ui.hud.classList.remove('visible');
            ui.over.classList.remove('visible');
            ui.menu.classList.remove('hidden');
            // Reset game state
            player.x = 400; player.y = 300; player.vx = 0; player.vy = 0;
            player.hp = 100; player.energy = 0; player.weaponLevel = 1;
            player.dashCooldown = 0; player.dashActive = 0; player.shootTimer = 0;
            player.iframe = 0; player.ultActive = 0; player.jumpCount = 0;
            kills = 0; combo = 0; comboTimer = 0; gameTime = 0;
            currentLevel = 1; levelKills = 0; bossActive = false; bossSpawned = false;
            enemies.length = 0; projectiles.length = 0; particles.length = 0;
            trails.length = 0; drops.length = 0;
        }
        window.returnHome = returnHome;

        function resize() {
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            // Scale canvas to fit viewport while maintaining aspect ratio
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const scaleX = vw / GAME_WIDTH;
            const scaleY = vh / GAME_HEIGHT;
            canvasScale = Math.max(scaleX, scaleY); // cover mode: fill screen
            canvas.style.transform = `scale(${canvasScale})`;
            // Center the canvas if it overflows in one direction
            const scaledW = GAME_WIDTH * canvasScale;
            const scaledH = GAME_HEIGHT * canvasScale;
            canvas.style.left = ((vw - scaledW) / 2) + 'px';
            canvas.style.top = ((vh - scaledH) / 2) + 'px';
        }
        window.addEventListener('resize', resize);
        resize();
    </script>
</body>

</html>